// ========================================================
// [코딩앙마] 자바스크립트 중급 강좌 : 140분 완성
// youtube : https://youtu.be/4_WLS9Lj6n4?si=Iyai7L_Oa4xWeQeG&t=1
//           https://www.youtube.com/watch?v=ocGc-AmWSnQ&list=PLZKTXPmaJk8JZ2NAC538UzhY_UNqMdZB4
// https://codepen.io/


// ========================================================
var name = "Mike";
console.log(name);

var name = "Jane";
console.log(name);


let name = "Mike";
console.log(name);

let name = "Jane";
console.log(name);  // Uncaught SyntaxError: Identifier 'name' has already been declared


console.log(name1);
var name1 = "Jane";

var name2;
console.log(name2);
name2 = "Jane";

console.log(name3);  // Uncaught ReferenceError: Cannot access 'name3' before initialization
let name3 = "Jane";


// Temporal Dead Zone

let age = 30;
function showAge() {
    console.log(age);
}
showAge();


let age = 30;
function showAge() {
    console.log(age);
    let age = 20;   // Uncaught ReferenceError: Cannot access 'age' before initialization 
}
showAge();


변수의 생성단계
1.선언
2.초기화
3.할당

let name;
name = 'Mike';

var age;
age = 30;

const gender = 'male';

// const gender;
// gender = 'male';  // Uncaught SyntaxError: Missing initializer in const declaration 



var        : function-scoped
let, const : block-scoped

- code block : 함수, if문, for문, while문, try/catch문 등


// ========================================================
// 생성자 함수

// 객체 리터럴
let user = {
    name: 'Mike',
    age: 30
}

console.log(user);


// 생성자 함수
function User(name, age) {
    this.name = name;
    this.age = age;
}

let user1 = new User('Mike', 30);
let user2 = new User('Jane', 22);
let user3 = new User('Tom', 17);

console.log(user1);
console.log(user2);
console.log(user3);


// 생성자 함수 내부로직
function User(name, age) {
    this = {}

    this.name = name;
    this.age = age;

    return this;
}

new 함수명();



function User(name, age) {
    this.name = name;
    this.age = age;
    this.sayName = function() {
        console.log(this.name);
    }
}

let user5 = new User('Han', 40);
user5.sayName();


function Item(title, price) {
    // this = {};

    this.title = title;
    this.price = price;

    this.showPrice = function() {
        console.log(this.price);
    }

    // return this;
}

const item1 = new Item('인형', 3000);
const item2 = new Item('가방', 5000);
const item3 = new Item('지갑', 9000);

console.log(item1, item2, item3);

item3.showPrice();


// ========================================================
// Object - methods / Computed property
// 10:41

// Computed property

let a = 'age';

const user = {
    name: 'Mike',
    age: 30
}

console.log(user);



let b = 'age';

const user2 = {
    name: 'Mike',
    [b]: 30   // age: 30
}

console.log(user2);


const user = {
    [1 + 4] : 5,
    ["안녕" + "하세요"]: "Hello"
}

console.log(user);


methods
- Object.assign()
- Object.keys()
- Object.values()
- Object.entries()
- Object.fromEntries()



// Object.assign() : 객체 복제

const user = {
    name: 'Mike',
    age: 30
}

const cloneUser = user; // 복제가 아닌 레퍼런스 주소를 할당함. 즉 user = cloneUser 임

console.log(user.name + " : " + cloneUser.name);

cloneUser.name = 'scott';
console.log(user.name + " : " + cloneUser.name);


//
const newUser = Object.assign({}, user);
console.log(user.name + " : " + newUser.name);

newUser.name = 'Tom';
console.log(user.name + " : " + newUser.name);

// 즉, newUser != user 임


const newProperty = Object.assign({gender: 'male'}, user);
console.log(newProperty);


const newProperty2 = Object.assign({name: 'Tiger'}, user);
console.log(newProperty2);


const user10 = {
  name: 'Mike'
}
const info1 = {
  age: 30
}
const info2 = {
  gender: 'male'
}

const newMerge = Object.assign(user10, info1, info2);
console.log(newMerge);



// Object.keys() : 키 배열 반환
// Object.values()
// Object.entries()
// Object.fromEntries()

const user11 = {
  name: "Mike",
  age: 30,
  gender: "male"
}

const newKeys = Object.keys(user11);
console.log(newKeys);  // ["name","age","gender"]


const newVales = Object.values(user11);
console.log(newVales);  // ["Mike",30,"male"]


console.log(Object.entries(user11));


const arr = [
  ["name","Scott"],
  ["age",25],
  ["gender","female"]
];
console.log(Object.fromEntries(arr));



let n = "name";
let a = "age";

const user20 = {
    [n]: "Mike",
    [a]: 30,
    [1+4]: 10,
};
console.log(user20);



function makeObj(key, val) {
    return {
        [key]: val,
    };
}

const obj = makeObj("나이", 33);
console.log(obj);




const user22 = {
    name: 'Mike',
    age: 30
}

const user23 = Object.assign({}, user22);
user23.name = 'Tom';

console.log(user22.name);
console.log(user23.name);

console.log(Object.keys(user22));
console.log(Object.values(user22));
console.log(Object.entries(user22));

let arr2 = [
    ['mon', '월'],
    ['tue', '화'],
];
const result = Object.fromEntries(arr2);
console.log(result);



// ========================================================
// Symbol 자료형
// 19:17

const obj = {
  1: '1입니다.',
  false: '거짓'
}

Object.keys(obj);

obj['1']
obj['false']



const a = Symbol();
const b = Symbol();

console.log(a);
console.log(b);

const id = Symbol('id');
const id2 = Symbol('id');

console.log(id);
console.log(id2);



const id3 = Symbol('id');

const user = {
  name: 'Mike',
  age: 30,
  [id3]: 'myid'
}

console.log(user);

console.log(Object.keys(user));   // ["name","age"]
console.log(Object.values(user)); // ["Mike",30]



// 다른 개발자가 만들어 놓은 객체
const user = {
  name: 'Mike',
  age: 30
}

// 내가 직접 추가한 객체 메소드

// user.showName2 = function() {};

const showName = Symbol("show name");
user[showName] = function() {
    console.log(this.name);
}

user[showName]();

// 사용자가 접속하면 보는 메시지
for (let key in user) {
    console.log(`His ${key} is ${user[key]}.`);
}



// ========================================================
// Number, Math
// 25:30

toString()

let num = 10;
num.toString(); // '10'
num.toString(2): // '1010'

let num2 = 255;
num2.toString(16);   // 'ff'


Math.PI;
3.14159265



let num11 = 5.1;
let num12 = 5.7;

console.log(Math.ceil(num11)); // 6
console.log(Math.ceil(num12)); // 6

console.log(Math.floor(num11));  // 5
console.log(Math.floor(num12));  // 5

console.log(Math.round(num11));  // 5
console.log(Math.round(num12));  // 6


let userRate = 30.1234;

// 요구사항 : 소수점 둘째자리까지 표현 (셋째자리에서 반올림)

console.log(Math.round(userRate * 100) / 100); // 30.12


console.log(userRate.toFixed(2)); // 30.12
console.log(userRate.toFixed(0)); // 30
console.log(userRate.toFixed(6)); // 30.123400

Number(userRate.toFixed(2));



let x = Number('x');  // NaN
console.log(isNaN(x));

x == NaN // false
x === NaN // false
NaN === NaN // false


let margin = '10px';

parseInt(margin); // 10
Number(margin);   // NaN

let redColor = 'f3';
parseInt(redColor); // NaN

parseInt(redColor, 16); // 16진수 - 243
parseInt('11', 2); // 2진수 - 3


let padding = '18.5%';

parseInt(padding); // 18
parseFloat(padding); // 18.5


Math.random();

console.log(Math.random());
console.log(Math.random()*100);
console.log(Math.floor(Math.random()*100)+1);



Math.max(1, 4, -1, 5, 10, 9, 5.54); // 10
Math.min(1, 4, -1, 5, 10, 9, 5.54); // -1

Math.abs(-1);   // 1

Math.pow(2, 10);   // 1024
Math.sqrt(16);  // 4



// ========================================================
// String
// 31:40

let desc = `오늘은 맑고
화창한 날씨가
계속됩니다.`;

console.log(desc);

let desc2 = `오늘은 맑고\n 화창한 날씨가\n 계속됩니다.`;

console.log(desc2);

console.log(desc.length);

console.log(desc[2]);
console.log(desc[4]);

let desc3 = "Hi guys. Nice to meet you."

console.log(desc3.toUpperCase());
console.log(desc3.toLowerCase());

console.log(desc3.indexOf('to')); // 14
console.log(desc3.indexOf('man')); // -1

// If 문과 사용시 주의
console.log(desc3.indexOf('Hi')); // 0

if (desc3.indexOf('Hi')) {  // indexOf 가 0 반환 = false 로 인식)
  console.log('Hi 가 포함된 문장입니다.');
}

if (desc3.indexOf('Hi') > -1) {
  console.log('Hi 가 포함된 문장입니다.');
}


let desc4 = 'abcdefg';

console.log(desc4.slice(2));  // "cdefg"
console.log(desc4.slice(0, 5));  // "abcde"
console.log(desc4.slice(2, -2)); // "cde"

console.log(desc4.substring(2, 5));  // "cde"
console.log(desc4.substring(5, 2));  // "cde"

console.log(desc4.substr(2, 5));  // "cdefg"
console.log(desc4.substr(5, 2));  // "fg"



let desc5 = '   abcdefg     ';

console.log(desc5);  // "   abcdefg     "
console.log(desc5.trim());  // "abcdefg"


let hello = 'hello';

console.log(hello.repeat(3)); // "hellohellohello"

console.log("A".codePointAt(0));  // 65
console.log("a".codePointAt(0));  // 97
console.log(String.fromCodePoint(65));  // "A"
console.log(String.fromCodePoint(97));  // "a"



let list = [
  "01. 들아가며",
  "02. JS의 역사",
  "03. 자료형",
  "04. 함수",
  "05. 배열",
];

let newList = [];

for (let i=0; i<list.length; i++) {
  newList.push(
    list[i].slice(4)
  );
}

console.log(newList);


// 금칙어 : 콜라

function hasCola(str) {
  if(str.indexOf('콜라')) {
    console.log('금칙어가 있습니다.');
  } else {
    console.log("통과");
  }
}

console.log(hasCola("사이다가 짱이야")); // -1 : 금칙어가 있습니다.
console.log(hasCola("무슨소리, 콜라가 짱이야"));  // 금칙어가 있습니다.
console.log(hasCola("콜라")); // 0 : 통과

function hasCola2(str) {
  if(str.indexOf('콜라') > -1) {
    console.log('금칙어가 있습니다.');
  } else {
    console.log("통과");
  }
}

console.log(hasCola2("사이다가 짱이야")); // 통과
console.log(hasCola2("무슨소리, 콜라가 짱이야")); // 금칙어가 있습니다.
console.log(hasCola2("콜라")); // 금칙어가 있습니다.


function hasCola3(str) {
  if(str.includes('콜라')) {
    console.log('금칙어가 있습니다.');
  } else {
    console.log("Pass");
  }
}

console.log(hasCola3("사이다가 짱이야")); // 통과
console.log(hasCola3("무슨소리, 콜라가 짱이야")); // 금칙어가 있습니다.
console.log(hasCola3("콜라")); // 금칙어가 있습니다.




// ========================================================
// Array
// 40:00

// push() : 뒤에 삽입
// pop() : 뒤에 삭제
// unshift() : 앞에 삽입
// shift() : 앞에 삭제

// arr.splice(n, m); // 특정 요소를 지움
// arr.splice(n, m, x); // 특정 요소를 지우고, 그 사이에 x 를 추가함

let arr = [1, 2, 3, 4, 5];
arr.splice(1, 2); // 배열인덱스 1부터 2개 데이터를 지움
console.log(arr); // [1,4,5]

let arr2 = [1, 2, 3, 4, 5];
arr2.splice(1, 3, 100, 200); // 배열인덱스 1부터 3개를 지우고, 그 사이에 100,200 을 추가함
console.log(arr2); // [1,100,200,5]

let arr3 = ["나는", "철수", "입니다"];
arr3.splice(1, 0, "대한민국", "소방관");
console.log(arr3); // ["나는","대한민국","소방관","철수","입니다"]

let arr4 = [1, 2, 3, 4, 5];
let result = arr4.splice(1, 2);
console.log(arr4); // [1,4,5]
console.log(result); // [2,3]



let arr10 = [1, 2, 3, 4, 5];
arr10.slice(1, 4);
console.log(arr10.slice(1, 4)); // [2,3,4]

let arr11 = arr10.slice();
console.log(arr11); // [1,2,3,4,5]


let arr20 = [1, 2];
console.log(arr20.concat([3,4])); // [1,2,3,4]
console.log(arr20.concat([3,4], [5,6]));  // [1,2,3,4,5,6]
console.log(arr20.concat([3,4], 5, 6));  // [1,2,3,4,5,6]


// forEach

let users = ["Mike", "Tom", "Jane"];

users.forEach((name, index) => {
  // console.log(name);
  console.log(`${index+1}. ${name}`);
});


let arr30 = [1,2,3,4,5,1,2,3];

console.log(arr30.indexOf(3));  // 2
console.log(arr30.indexOf(3,3));  // 7

console.log(arr30.lastIndexOf(3));  // 7


let arr31 = [1,2,3];

console.log(arr31.includes(2)); // true
console.log(arr31.includes(8)); // false


// find(fn) / findIndex(fn)

let arr32 = [1, 2, 3, 4, 5];

const result2 = arr32.find((item) => {
  return item % 2 === 0;
});
                          
console.log(result2); // 2


let userList2 = [
  {name: "Mike", age: 30},
  {name: "Jane", age: 27},
  {name: "Tom", age: 10},
];

const result3 = userList2.find((u) => {
  if (u.age < 19) {
    return true;
  }
  return false;
});

console.log(result3); // 

const result4 = userList2.findIndex((u) => {
  if (u.age < 19) {
    return true;
  }
  return false;
});

console.log(result4); // 2 : 조건을 만족하는 배열의 인덱스번호 반환


// arr.find(fn) : 조건을 만족하는 첫번째 요소만 반환
// arr.filter(fn) : 조건을 만족하는 모든 요소를 배열로 반환

let arr33 = [1, 2, 3, 4, 5, 6];

const result33 = arr33.find((item) => {
  return item % 2 === 0;
});
                          
console.log(result33); // 2

const result34 = arr33.filter((item) => {
  return item % 2 === 0;
});
                          
console.log(result34); // [2,4,6]


let arr40 = [1, 2, 3, 4, 5, 6];
console.log(arr40.reverse()); // [6,5,4,3,2,1]


// arr.map(fn) : 함수를 받아, 특정 기능을 시행하고, 새로운 배열로 반환

let userList3 = [
  {name: "Mike", age: 30},
  {name: "Jane", age: 27},
  {name: "Tom", age: 10},
];

let newUserList3 = 
    userList3.map((user, index) => {
      return Object.assign({}, user, {
        id: index + 1,
        isAdult: user.age > 19,
      });
    });

console.log(userList3);
console.log(newUserList3);

// [
//   {
//     "name": "Mike",
//     "age": 30,
//     "id": 1,
//     "isAdult": true
//   },
//   {
//     "name": "Jane",
//     "age": 27,
//     "id": 2,
//     "isAdult": true
//   },
//   {
//     "name": "Tom",
//     "age": 10,
//     "id": 3,
//     "isAdult": false
//   }
// ]


// join, split

let arr50 = ["안녕", "나는", "철수야"];

let result50 = arr50.join("-");

console.log(result50);  // "안녕-나는-철수야"


const users51 = "Mike,Jane,Tom,Tony";
const result51 = users51.split(",");
console.log(result51);  // ["Mike","Jane","Tom","Tony"]

const str52 = "Hello, My Name is";
const result52 = str52.split("");
console.log(result52);  // ["H","e","l","l","o",","," ","M","y"," ","N","a","m","e"," ","i","s"]


// Array.isArray()

let user53 = {
  name: "Mike",
  age: 30
};

let userList53 = ["Mike", "Tom", "Jane"];

console.log(typeof user53); // "object"
console.log(typeof userList53); // "object"

console.log(Array.isArray(user53)); // false
console.log(Array.isArray(userList53)); // true



// ========================================================
// Array 2nd
// 52:40

arr.sort()
배열 재정렬
주의! 배열 자체가 변경됨.

let arr = [1, 5, 4, 2, 3];

arr.sort();

console.log(arr);



// arr.sort()
// 배열 재정렬
// 주의! 배열 자체가 변경됨.
// 인수로 정렬 로직을 담은 함수를 받음 : arr.sort(fn)

let arr = [1, 5, 4, 2, 3];

arr.sort();

console.log(arr);



let arr2 = [27, 8, 5, 13];

// 8, 27, 5, 13
// 5, 8, 27, 13
// 5, 8, 13, 27

arr2.sort((a,b) => {
  console.log(a, b);
  return a-b;
});

console.log(arr2);



// lodash.com
// _.sortBy(arr2);


// arr.reduce()
// 인수로 함수를 받음
// (누적 계산값, 현재값) => {return 계산값};

// 배열의 모든 수를 합하기

let arr3 = [1, 2, 3, 4, 5];

// for, for of, forEach

let result = 0;
arr3.forEach((num) => {
  result += num;
});

console.log(result);  // 15


// arr.reduce()

const result2 = arr.reduce((prev, cur) => {
  return prev + cur;
}, 0);  // 0: 초기값

console.log(result2);



let userList = [
  {name: "Mike", age: 30},
  {name: "Tom", age: 10},
  {name: "Jane", age: 27},
  {name: "Sue", age: 26},
  {name: "Harry", age: 43},
  {name: "Steve", age: 60},
];

// console.log(userList);

let result3 = userList.reduce((prev, cur) => {
  if (cur.age > 19) {
    prev.push(cur.name);
  }
  return prev;
}, []);

console.log(result3);


result3 = userList.reduce((prev, cur) => {
  return prev += cur.age;
}, 0);

console.log(result3);


result3 = userList.reduce((prev, cur) => {
  if (cur.name.length === 3) {
    prev.push(cur.name);
  }
  return prev;
}, []);

console.log(result3);


// ========================================================
// 구조 분해 할당 (Destructuring assignment)
// : 배열이나 객체의 속성을 분해해서 그 값을 변수에 담을 수 있게 하는 표현식
// 1:03:20

let [x, y] = [1, 2];

console.log(x); // 1
console.log(y); // 2



let users = ['Mike', 'Tom', 'Jane'];
let [user1, user2, user3] = users;

console.log(user1);
console.log(user2);
console.log(user3);


let str = 'Mike,Tom,Jane';
[user1, user2, user3] = str.split(',');

console.log(user1);
console.log(user2);
console.log(user3);

let [a, b, c] = [1, 2];
console.log(a);
console.log(c);   // undefined

[a=3, b=4, c=5] = [1, 2];
console.log(a);
console.log(c);   // 5


let [user21, , user22] = ['Mike', 'Tom', 'Jane', 'Tony'];
console.log(user21);  // Mike
console.log(user22);  // Jane


// 배열 구조 분해 : 바꿔치기

let a1 = 1;
let b1 = 2;
let c1 = a1;

console.log(a1);
console.log(b1);

a1 = b1;
b1 = c1;

console.log(a1);
console.log(b1);

[a1, b1] = [b1, a1];

console.log(a1);
console.log(b1);


// 객체 구조 분해

let user4 = {name4: 'Mike', age4:31};
let {name4, age4} = user4;

// let name4 = user4.name;
// let age4 = user4.age;

console.log(name4);
console.log(age4);

// name4, age4 가 아닌 새로운 변수 이름으로 할당

let {name4: userName, age4: userAge} = user4;

console.log(userName);
console.log(userAge);



let user5 = {name5: 'Mike', age5:31};
// let {name5, age5, gender5} = user5;

// console.log(gender5); // undefined

let {name5, age5, gender5 = 'male'} = user5;

console.log(gender5); // male





// ========================================================
// 나머지 매개변수, 전개구문 (Rest parameters, Spread syntax)
// 1:07:48

// 인수전달

function showName(name) {
  console.log(name);
}

showName('Mike'); // "Mike"
showName('Mike', 'Tom');  // "Mike"
showName(); // undefined


// arguments
// 함수로 넘어온 모든 인수에 접근
// 함수 내에서 이용 가능한 지역변수
// length / index
// Array 형태의 객체
// 배열의 내장 메서드 없음 (forEach, map)

function showName(name) {
  console.log(arguments.length);  // 2
  console.log(arguments[0]);  // Mike
  console.log(arguments[1]);  // Tom
}

showName('Mike', 'Tom');

// 나머지 매개변수 (Rest parameters)

function showName(...names) {
  console.log(names);
}

showName(); // []
showName('Mike');// ["Mike"]
showName('Mike', 'Tom');  // ["Mike","Tom"]



// 나머지 매개변수
// 파라미터 갯수가 가변적일때...

function add(...numbers) {
  let result = 0;
  numbers.forEach((num) => (result += num));
  console.log(result);
};

add(1, 2, 3);
add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

function add2(...numbers) {
  let result = numbers.reduce((prev, cur) => (prev + cur));
  console.log(result);
};

add2(1, 2, 3);
add2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);



// 나머지 매개변수
// user 객체를 만들어 주는 생성자 함수 생성

function User(name, age, ...skills) {
  this.name = name;
  this.age = age;
  this.skills = skills;
}

const user1 = new User("Mike", 30, "html", "css");
const user2 = new User("Tom", 20, "JS", "React");

console.log(user1);
console.log(user2);



// 전개 구문 : 배열

let arr11 = [1, 2, 3];
let arr12 = [4, 5, 6];

let result10 = [...arr11, ...arr12];

console.log(result10);  // [1,2,3,4,5,6]

let result11 = [0, ...arr11, ...arr12, 7, 8, 9];

console.log(result11);  // [0,1,2,3,4,5,6,7,8,9]

// arr.push(), arr.splice, arr.concat



// 전개 구문 : 복제

let arr21 = [1, 2, 3];
let arr22 = [...arr21]; // [1, 2, 3]

let user21 = {name: 'Mike', age: 30};
let user22 = {...user21};

user22.name = "Tom";

console.log(user21.name); // "Mike"
console.log(user22.name); // "Tom"


// 전개구문
// arr31 을 [4,5,6,1,2,3] 으로 만들기

let arr31 = [1, 2, 3];
let arr32 = [4, 5, 6];

arr32.forEach(num => {
  arr31.unshift(num);
});

console.log(arr31); // [6,5,4,1,2,3] <- 잘못된 결과

let arr33 = [1, 2, 3];
let arr34 = [4, 5, 6];

arr34.reverse().forEach(num => {
  arr33.unshift(num);
});

console.log(arr33); // [4,5,6,1,2,3]

// 위 내용을 전개구문으로 풀어보면...

let arr35 = [1, 2, 3];
let arr36 = [4, 5, 6];

arr35 = [...arr36, ...arr35];

console.log(arr35); // [4,5,6,1,2,3]




let user41 = {name: "Mike"};
let info41 = {age: 30};
let fe41 = ["JS", "React"];
let lang41 = ["Korean", "English"];

user41 = Object.assign(
  {},
  user41,
  info41,
  {
    skills: []
  }
);

fe41.forEach(item => {
  user41.skills.push(item);
});

lang41.forEach(item => {
  user41.skills.push(item);
});

user41.skill2 = [...fe41, ...lang41];

console.log(user41);


let user42 = {name: "Mike"};
let info42 = {age: 30};
let fe42 = ["JS", "React"];
let lang42 = ["Korean", "English"];

user42 = {
  ...user42,
  ...info42,
  skills: [
    ...fe42,
    ...lang42
  ]
};

console.log(user42);



// ========================================================
// 클로저 (Closure)
// 01:18:39

// 어휘적 환경 (Lexical Environment)

// 어휘적 환경 (Lexical Environment)

let one;
one = 1;

function addOne(num) {
  console.log(one + num);
}

addOne(5);  // 6


function makeAddr(x) {
  return function(y) {
    return x + y;
  }
};

const add3 = makeAddr(3); // 6
console.log(add3(2)); // 5

const add10 = makeAddr(10);
console.log(add10(5)); // 15
console.log(add3(1)); // 4

// closure
// 함수와 lexical 환경의 조합
// 함수가 생성될 당시의 외부 변수를 기억
// 생성 이후에도 계속 접근 가능

function makeCounter() {
  let num = 0;  // 은닉화
  
  return function() {
    return num++;
  };
}

let counter = makeCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2



// ========================================================
// setTimeout / setInterval
// 01:23:38

function fn() {
    console.log(3);
}

setTimeout(fn, 3000);



setTimeout(function () {
    console.log(3);
}, 3000);



function showName(name) {
    console.log(name);
}

setTimeout(showName, 3000, 'Mike');



function showName2(name) {
    console.log(name);
}

const timeID = setTimeout(showName2, 3000, 'Mike');

clearTimeout(timeID);



function showName3(name) {
    console.log(name);
}

const timeId2 = setInterval(showName3, 3000, 'Mike');

clearInterval(timeID2);


//

let num = 0;

function showTime() {
  console.log(`접속하신지 ${num++} 가 지났습니다.`);
  if (num > 5) {
    clearInterval(timeID3);
  }
};

const timeID3 = setInterval(showTime, 1000);




// ========================================================
// call, apply, bind
// 01:26:43

// call, apply, bind
// 함수 호출 방식과 관계없이 this 를 지정할 수 있음

// call

const mike = {
  name: "Mike"
};

const tom = {
  name: "Tom"
};

function showThisName() {
  console.log(this.name);
};

console.log(showThisName());  // window.name = ""
console.log(showThisName.call(mike));
console.log(showThisName.call(tom));

function update(birthYear, occupation) {
  this.birthYear = birthYear;
  this.occupation = occupation;
}

update.call(mike, 1990, "singer");
console.log(mike);

update.call(tom, 2002, "teacher");
console.log(tom);


// apply

const mike2 = {
  name: "Mike"
};

const tom2 = {
  name: "Tom"
};

function showThisName2() {
  console.log(this.name);
};

function update(birthYear, occupation) {
  this.birthYear = birthYear;
  this.occupation = occupation;
}

// apply 는 매개변수를 배열로 전달
update.apply(mike2, [1990, "singer"]);
console.log(mike2);

update.apply(tom2, [2002, "teacher"]);
console.log(tom2);



const nums = [3, 10, 1, 6, 4];

const minNum = Math.min(...nums);
const maxNum = Math.max(...nums);
console.log(minNum);
console.log(maxNum);

const minNum2 = Math.min.apply(null, nums);
const maxNum2 = Math.max.apply(null, nums);
// const maxNum2 = Math.max.apply(null, [3, 10, 1, 6, 4]);
console.log(minNum2);
console.log(maxNum2);

const minNum3 = Math.min.call(null, ...nums);
const maxNum3 = Math.max.call(null, ...nums);
// const maxNum3 = Math.max.call(null, 3, 10, 1, 6, 4);
console.log(minNum3);
console.log(maxNum3);




// bind

const mike5 = {
  name: "Mike"
};

function update5(birthYear, occupation) {
  this.birthYear = birthYear;
  this.occupation = occupation;
}

const updateMike = update5.bind(mike5);
console.log(mike5);

updateMike(1980, "police");
console.log(mike5);




const user5 = {
  name: "Mike",
  showName: function() {
    console.log(`hello, ${this.name}`);
  },
};

console.log(user5.showName());

let fn5 = user5.showName;
fn5();

fn5.call(user5);
fn5.apply(user5);

let boundFn = fn5.bind(user5);
boundFn();



// ========================================================
// 상속, prototype
// 01:33:40

const user = {
  name: 'Mike'
};

console.log(user.name); // Mike
console.log(user.hasOwnProperty('name')); // true
console.log(user.hasOwnProperty('age'));  // false


const user2 = {
  name: 'Mike',
  hasOwnProperty: function() {
    console.log('haha');
  }
};

console.log(user2.hasOwnProperty());


// =======================

const bmw = {
  color: "red",
  navigation: 1,
  wheels: 4,
  drive() {
    console.log("drive...");
  },
};

const benz = {
  color: "black",
  wheels: 4,
  drive() {
    console.log("drive...");
  },
};

const audi = {
  color: "blue",
  wheels: 4,
  drive() {
    console.log("drive...");
  },
};

// =======================

const car = {
  wheels: 4,
  drive() {
    console.log("drive...");
  },
};

const bmw2 = {
  color: "red",
  navigation: 1,
};

const benz2 = {
  color: "black",
};

const audi2 = {
  color: "blue",
};

bmw2.__proto__ = car;
benz2.__proto__ = car;
audi2.__proto__ = car;

console.log(bmw2.color);
console.log(bmw2.wheels);
console.log(bmw2.drive());


// =======================

const car3 = {
  wheels: 4,
  drive() {
    console.log("drive...");
  },
};

const bmw3 = {
  color: "red",
  navigation: 1,
};

bmw3.__proto__ = car3;

const x5 = {
  color: "white",
  name: "x5",
};

x5.__proto__ = bmw3;

console.log(x5.color);
console.log(x5.navigation);
console.log(x5.wheels);
console.log(x5.drive());

for (p in x5) {
  console.log(p);
};

console.log(Object.keys(x5)); // ["color","name"]
console.log(Object.values(x5)); // ["white","x5"]

for (p in x5) {
  if (x5.hasOwnProperty(p)) {
    console.log('[O] ', p);
  } else {
    console.log('[X] ', p);
  }
};



// 생성자 함수

const Bmw5 = function (color) {
  this.color = color;
  this.wheels = 4;
  this.drive = function () {
    console.log("drive...");
  };
};

const b_x5 = new Bmw5("red");
const b_z4 = new Bmw5("white");

console.log(b_x5.color);



// 생성자 함수 (2)

const car6 = {
  wheels: 4,
  drive() {
    console.log("drive...");
  },
};

const Bmw6 = function (color) {
  this.color = color;
};

const b6_x5 = new Bmw6("red");
const b6_z4 = new Bmw6("white");

b6_x5.__proto__ = car6;
b6_z4.__proto__ = car6;

console.log(b6_x5.color);
console.log(b6_x5.wheels);



// 생성자 함수 (3)

const Bmw7 = function (color) {
  this.color = color;
};

Bmw7.prototype.wheels = 4;
Bmw7.prototype.drive = function () {
    console.log("drive...");
};

const b7_x5 = new Bmw7("red");
const b7_z4 = new Bmw7("white");

console.log(b7_x5.color);
console.log(b7_x5.wheels);



// 생성자 함수 (4)

const Bmw8 = function (color) {
  this.color = color;
};

Bmw8.prototype.wheels = 4;
Bmw8.prototype.drive = function () {
    console.log("drive...");
};
Bmw8.prototype.navigation = 1;
Bmw8.prototype.stop = function () {
    console.log("STOP !!");
};

const b8_x5 = new Bmw8("red");
const b8_z4 = new Bmw8("white");

console.log(b8_x5.color);
console.log(b8_x5.stop());


console.log(b8_x5 instanceof Bmw8); // true
console.log(b8_x5.constructor === Bmw8); // true



// 생성자 함수 (5)

const Bmw9 = function (color) {
  this.color = color;
};

Bmw9.prototype = {
  wheels: 4,
  drive() {
    console.log("drive...");
  },
  navigation: 1,
  stop() {
    console.log("STOP !!");
  }
};

let b9_x5 = new Bmw9("red");
let b9_z4 = new Bmw9("white");

console.log(b9_x5.color);
console.log(b9_z4.stop());


console.log(b9_z4 instanceof Bmw9); // true
console.log(b9_x5.constructor === Bmw9); // false



Bmw9.prototype = {
  constructor: Bmw9,  // <== 이렇게 명시해주는게 좋음
  wheels: 4,
  drive() {
    console.log("drive...");
  },
  navigation: 1,
  stop() {
    console.log("STOP !!");
  }
};

b9_x5 = new Bmw9("red");
b9_z4 = new Bmw9("white");

console.log(b9_x5.color);
console.log(b9_z4.stop());

console.log(b9_z4 instanceof Bmw9); // true
console.log(b9_x5.constructor === Bmw9); // true



// 색상을 맘대로 변경할 수 있는 문제점이 있음.
// 이를 해결하기 위해 Closure 를 이용함

const Bmw10 = function (color) {
  this.color = color;
};

b10_x5 = new Bmw10("red");
console.log(b10_x5.color);

b10_x5.color = "black";
console.log(b10_x5.color);

const Bmw11 = function (color) {
  const c = color;
  this.getColor = function () {
    console.log(c);
  }
};

b11_x5 = new Bmw11("red");
console.log(b11_x5.getColor());



// ========================================================
// Class (ES6 에 추가된 개념)
// 01:43:00

const User = function (name, age) {
  this.name = name;
  this.age = age;
  this.showName = function () {
    console.log(this.name);
  };
};

const mike = new User("Mike", 30);
console.log(mike);


class User2 {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  showName() {
    console.log(this.name);
  }
}

const tom = new User2("Tom", 19);
console.log(tom);


const User3 = function (name, age) {
  this.name = name;
  this.age = age;
  // this.showName = function () {
  //   console.log(this.name);
  // };
};

User3.prototype.showName = function () {
  console.log(this.name);
};

const mike3 = new User3("Mike", 30);
console.log(mike3);




for (const p in mike3) {
  console.log(p);
}; // name, age, showName

for (const p in tom) {
  console.log(p);
}; // name, age



// 상속 extends

class Car {
  constructor(color) {
    this.color = color;
    this.wheels = 4;
  }
  drive() {
    console.log("drive.");
  }
  stop() {
    console.log("STOP !");
  }
}

class Bmw extends Car {
  park() {
    console.log("Park");
  }
}

const z4 = new Bmw("blue");

console.log(z4);
console.log(z4.stop());

// 메소드 오버라이딩 (method overriding)

class Bmw2 extends Car {
  park() {
    console.log("Park");
  }
  stop() {
    console.log("OFF !");
  }
}

const z4_2 = new Bmw2("blue");

console.log(z4_2);
console.log(z4_2.stop());



class Bmw3 extends Car {
  park() {
    console.log("Park");
  }
  stop() {
    super.stop();
    console.log("OFF !");
  }
}

const z4_3 = new Bmw3("blue");

console.log(z4_3);
console.log(z4_3.stop());


// 생성자 오버라이딩 (overriding)

class Car5 {
  constructor(color) {
    this.color = color;
    this.wheels = 4;
  }
  drive() {
    console.log("drive.");
  }
  stop() {
    console.log("STOP !");
  }
}

class Bmw5 extends Car5 {
  constructor(color) {
    super(color);
    this.navigation = 1;
  }
  park() {
    console.log("Park");
  }
}

const b5_z4 = new Bmw5("blue");
console.log(b5_z4.color);



// ========================================================
// Promise
// 01:53:10

const pr = new Promise((resolve, reject) => {
  // code
});


const pr2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('OK!');
  }, 3000);
});


const pr3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('error'));
  }, 3000);
});


pr2.then(
  function(result) {
    console.log(result + '=> Go');
  },
  function(err) {
    console.log(err + '=> Reorder');
  }
);

pr2.then(
  function(result) {
    console.log(result + '=> Go');
  }
).catch(
  function(err) {
    console.log(err + '=> Reorder');
  }
);

pr2.then(
  function(result) {
    console.log(result + '=> Go');
  }
).catch(
  function(err) {
    console.log(err + '=> Reorder');
  }
).finally(
  function() {
    console.log('End');
  }
);



const pr5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('OK!');
    // reject(new Error("err..."));
  }, 1000);
});

console.log("시작");

pr5.then((result) => {
  console.log(result);
}).catch((err) => {
  console.log(err);
}).finally(() => {
  console.log('End');
});


// callback 함수로 구현

const f1 = (callback) => {
  setTimeout(function () {
    console.log("[callback] 1번 주문");
    callback();
  }, 1000);
};

const f2 = (callback) => {
  setTimeout(function () {
    console.log("[callback] 2번 주문");
    callback();
  }, 3000);
};

const f3 = (callback) => {
  setTimeout(function () {
    console.log("[callback] 3번 주문");
    callback();
  }, 2000);
};

console.log("[callback] 시작");

f1(function() {
  f2(function() {
    f3(function() {
      console.log('[callback] 끝');
    })
  })
})


// promise 로 구현

const f11 = () => {
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise] 1번 주문");
    }, 1000);
  });
};

const f12 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise] 2번 주문");
    }, 3000);
  });
};

const f13 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise] 3번 주문");
    }, 2000);
  });
};

console.log("[Promise] 시작");

// promise chaining
f11()
.then((res) => f12(res))
.then((res) => f13(res))
.then((res) => console.log(res))
.catch(console.log)
.finally(() => {
  console.log("[Promise] 끝");
});



// promise 로 구현 (2)

const f21 = () => {
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise-2] 1번 주문");
    }, 1000);
  });
};

const f22 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      rej("[Promise-2] 실패");
    }, 3000);
  });
};

const f23 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise-2] 3번 주문");
    }, 2000);
  });
};

console.log("[Promise-2] 시작");

// promise chaining
f21()
.then((res) => f22(res))
.then((res) => f23(res))
.then((res) => console.log(res))
.catch(console.log)
.finally(() => {
  console.log("[Promise-2] 끝");
});



// Promise.all
// Promise.all( [f1(), f2(), f3()] )
console.time("xxx");

Promise.all( [f11(), f12(), f13()] ).then((res) => {
  console.log(res);
  console.timeEnd("xxx");
});

// ["[Promise] 1번 주문","[Promise] 2번 주문","[Promise] 3번 주문"]


console.time("yyy");

Promise.all( [f21(), f22(), f23()] ).then((res) => {
  console.log(res);
  console.timeEnd("yyy");
});



// Promise.race
// Promise.race( [f1(), f2(), f3()] )
console.time("xxx");
Promise.race( [f11(), f12(), f13()] ).then((res) => {
  console.log(res);
  console.timeEnd("xxx");
});



// ========================================================
// async, await
// 02:05:40

async function getName() {
  return "Mike";
}

getName().then((name) => {
  console.log(name);
});



async function getName2() {
  return Promise.resolve("Tom");
}

getName2().then((name) => {
  console.log(name);
});



async function getName3() {
  // return Promise.resolve("Tom");
  throw new Error("err..");
}

getName3()
  .then((name) => {
    console.log(name);
  })
  .catch((err) => {
    console.log(err);
  });


// await

function getName(name) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(name);
    }, 1000);
  });
}

async function showName() {
  const result = await getName("Mike");
  console.log(result);
};

console.log("시작");
showName();




const f11 = () => {
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise] 1번 주문");
    }, 1000);
  });
};

const f12 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise] 2번 주문");
    }, 3000);
  });
};

const f13 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise] 3번 주문");
    }, 2000);
  });
};

console.log("[Promise] 시작");

// // promise chaining
// f11()
// .then((res) => f12(res))
// .then((res) => f13(res))
// .then((res) => console.log(res))
// .catch(console.log)
// .finally(() => {
//   console.log("[Promise] 끝");
// });

async function order() {
  const result1 = await f11();
  const result2 = await f12(result1);
  const result3 = await f13(result2);
  
  console.log(result3);
  console.log("[Promise] 끝");
}

order();





// promise 로 구현 (2)

const f21 = () => {
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise-2] 1번 주문");
    }, 1000);
  });
};

const f22 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      rej(new Error("[Promise-2] Err..."));
    }, 3000);
  });
};

const f23 = (message) => {
  console.log(message);
  return new Promise((res, rej) => {
    setTimeout(function () {
      res("[Promise-2] 3번 주문");
    }, 2000);
  });
};

console.log("[Promise-2] 시작");

async function order2() {
  try {
    const result1 = await f21();
    const result2 = await f22(result1);
    const result3 = await f23(result2);
    console.log(result3);    

  } catch (e) {
    console.log(e);
  
  } finally {
    console.log("[Promise] 끝");
  }  
}

order2();


async function order3() {
  try {
    const result = await Promise.all([f11(), f12(), f13()]);
    console.log(result);    

  } catch (e) {
    console.log(e);
  
  } finally {
    console.log("[Promise] 끝");
  }  
}

order3();



// ========================================================
// Generator
// 02:10:50

// Generator : 함수의 실행을 중간에 멈췄다가 재개할 수 있는 기능

// Generator : 함수의 실행을 중간에 멈췄다가 재개할 수 있는 기능
//
// next(), return(), throw()
// iterable
// - Symbol.iterator 메소드가 있음
// - Symbol.iterator 메소드는 iterator 를 반환해야 함
//
// iterator
// - next 메소드를 가짐
// - next 메소드는 value 와 done 속성을 가진 객체를 반환함
// - 작업이 끝나면, done 은 true 가 됨


// function* fn() {
//   yield 1;
//   yield 2;
//   yield 3;
//   return "finish";
// }

// const a = fn();


// function* fn2() {
//   console.log(1);
//   yield 100;
  
//   console.log(2);  
//   yield 200;
  
//   console.log(3);
//   console.log(4);
//   yield 300;
  
//   return "finish1";
// }

// const a2 = fn2();
// // a2.next();
// // a2.next();
// // a2.next();
// // a2.next();


// function* fn3() {
//   console.log(1);
//   yield 100;
  
//   console.log(2);  
//   yield 200;
  
//   console.log(3);
//   console.log(4);
//   yield 300;
  
//   return "finish1";
// }

// const a3 = fn3();
// // a3.next();
// // a3.next();
// // a3.return('END');
// // a3.next();


// function* fn4() {
//   try {
//     console.log(1);
//     yield 100;

//     console.log(2);  
//     yield 200;

//     console.log(3);
//     console.log(4);
//     yield 300;

//     return "finish1";
//   } catch (e) {
//     console.log(e);
//   }
// }

// const a4 = fn4();
// // a4.next();
// // a4.next();
// // a4.throw(new Error('err'));
// // a4.next();


// const arr = [1, 2, 3, 4, 5];

// const it = arr[Symbol.iterator]();

// // it.next();
// // it.next();
// // it.next();
// // it.next();
// // it.next();

// for(let num of arr) {
//   console.log(num);
// }


// function* fn10() {
//   yield 4;
//   yield 5;
//   yield 6;
// }

// const a10 = fn10();

// console.log(a10[Symbol.iterator]() === a10);  // true

// for(let num of a10) {
//   console.log(num);
// }


// function* fn20() {
//   const num1 = yield "첫번째 숫자를 입력하세요";
//   console.log(num1);
  
//   const num2 = yield "첫번째 숫자를 입력하세요";
//   console.log(num2);
  
//   return num1 + num2;
// }

// const a20 = fn20();

// // a20.next();
// // a20.next(15);
// // a20.next(25);


// function* fn30() {
//   let index = 0;
//   while(true) {
//     yield index++;
//   }
// }

// const a30 = fn30();

// // a30.next();
// // a30.next();
// // a30.next();
// // a30.next();
// // a30.next();



function* gen1() {
  yield "w";
  yield "o";
  yield "r";
  yield "l";
  yield "d";
}

function* gen2() {
  yield "hello";
  yield* gen1();
  yield "!";
}

console.log(...gen2());

